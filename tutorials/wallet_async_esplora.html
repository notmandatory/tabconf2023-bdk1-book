<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Wallet with Async Explora - Bitcoin Dev Kit (1.0) Documentation</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../quick_start.html">Quickstart</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="../bdk.html"><strong aria-hidden="true">1.</strong> BDK Wallet</a></li><li class="chapter-item expanded "><a href="../store.html"><strong aria-hidden="true">2.</strong> File Store</a></li><li class="chapter-item expanded "><a href="../blockchain/index.html"><strong aria-hidden="true">3.</strong> Blockchain Clients</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../blockchain/esplora.html"><strong aria-hidden="true">3.1.</strong> Esplora</a></li><li class="chapter-item expanded "><a href="../blockchain/electrum.html"><strong aria-hidden="true">3.2.</strong> Electrum</a></li></ol></li><li class="chapter-item expanded "><a href="../chain.html"><strong aria-hidden="true">4.</strong> Chain</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="../tutorials/wallet_async_esplora.html" class="active"><strong aria-hidden="true">5.</strong> Wallet with Async Explora</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Bitcoin Dev Kit (1.0) Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="wallet-with-async-explora"><a class="header" href="#wallet-with-async-explora">Wallet with Async Explora</a></h1>
<ol>
<li>
<p>Create a new Rust project:</p>
<pre><code class="language-shell">cargo init my_bdk_app
cd my_bdk_app
</code></pre>
</li>
<li>
<p>Add <code>bdk</code> to your <code>Cargo.toml</code> file. <del>Find the latest <code>BDK@1.0.0</code> release on <a href="https://crates.io/crates/bdk/versions"><code>crates.io</code></a></del> (use pre-released branch for now):</p>
<pre><code class="language-shell"> cargo add bdk --git &quot;https://github.com/notmandatory/bdk.git&quot; --branch &quot;test/esplora_tests&quot;
</code></pre>
</li>
<li>
<p>Add other required dependencies:</p>
<pre><code class="language-shell">cargo add bdk_esplora --git &quot;https://github.com/notmandatory/bdk.git&quot; --branch &quot;test/esplora_tests&quot;
cargo add bdk_file_store --git &quot;https://github.com/notmandatory/bdk.git&quot; --branch &quot;test/esplora_tests&quot;
cargo add tokio@1 --features &quot;rt,rt-multi-thread,macros&quot;
</code></pre>
</li>
<li>
<p>Edit <code>src/main.rs</code>, replace with below code to load or create and save new descriptors:</p>
<pre><pre class="playground"><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::string::ToString;
use std::{io::Write, str::FromStr};

use bdk::bitcoin::bip32;
use bdk::bitcoin::bip32::ExtendedPrivKey;
use bdk::bitcoin::secp256k1::{rand, rand::RngCore, Secp256k1};

use bdk::{bitcoin::Network, descriptor};

use bdk::descriptor::IntoWalletDescriptor;
use bdk::keys::IntoDescriptorKey;

const CONFIG_FILE: &amp;str = &quot;config.txt&quot;;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
// Create and load or save new descriptors

    let secp = Secp256k1::new();
    let network = Network::Signet;

    // get descriptors from config.txt file, if file is missing create a new ones
    let descriptors = match File::open(CONFIG_FILE) {
        // load descriptors from file
        Ok(mut file) =&gt; {
            let mut config = String::new();
            file.read_to_string(&amp;mut config)?;
            let descriptor_strings: [_; 2] = config
                .split(&quot;|&quot;)
                .map(|d| d.to_string())
                .collect::&lt;Vec&lt;_&gt;&gt;()
                .try_into()
                .unwrap();
            let external_descriptor = descriptor_strings[0]
                .into_wallet_descriptor(&amp;secp, network)
                .unwrap();
            let internal_descriptor = descriptor_strings[1]
                .into_wallet_descriptor(&amp;secp, network)
                .unwrap();
            (external_descriptor, internal_descriptor)
        }
        Err(_) =&gt; {
            // create new descriptors and save them to the file
            let mut seed = [0u8; 32];
            rand::thread_rng().fill_bytes(&amp;mut seed);
            let xprv = ExtendedPrivKey::new_master(network, &amp;seed).unwrap();
            let bip86_external = bip32::DerivationPath::from_str(&quot;m/86'/1'/0'/0/0&quot;).unwrap();
            let bip86_internal = bip32::DerivationPath::from_str(&quot;m/86'/1'/0'/0/1&quot;).unwrap();
            let external_key = (xprv, bip86_external).into_descriptor_key().unwrap();
            let internal_key = (xprv, bip86_internal).into_descriptor_key().unwrap();
            let external_descriptor = descriptor!(tr(external_key))
                .unwrap()
                .into_wallet_descriptor(&amp;secp, network)
                .unwrap();
            let internal_descriptor = descriptor!(tr(internal_key))
                .unwrap()
                .into_wallet_descriptor(&amp;secp, network)
                .unwrap();
            // save descriptor strings to file
            let mut file = File::create(CONFIG_FILE).unwrap();
            println!(&quot;Created new descriptor config file: config.txt&quot;);
            let config = format!(
                &quot;{}|{}&quot;,
                &amp;external_descriptor
                    .0
                    .to_string_with_secret(&amp;external_descriptor.1),
                &amp;internal_descriptor
                    .0
                    .to_string_with_secret(&amp;internal_descriptor.1)
            );
            file.write(config.as_bytes()).unwrap();
            (external_descriptor, internal_descriptor)
        }
    };

    let external_descriptor = descriptors.0;
    let internal_descriptor = descriptors.1;
    println!(
        &quot;External descriptor: {}&quot;,
        &amp;external_descriptor
            .0
            .to_string_with_secret(&amp;external_descriptor.1)
    );
    println!(
        &quot;Internal descriptor: {}\n&quot;,
        &amp;internal_descriptor
            .0
            .to_string_with_secret(&amp;internal_descriptor.1)
    );

    Ok(())
}</code></pre></pre>
</li>
<li>
<p>Add code to create a wallet and get a new address and current wallet balance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bdk::{bitcoin::Network, descriptor, Wallet};
use bdk::wallet::AddressIndex;
use bdk_file_store::Store;

const CHAIN_DATA_FILE: &amp;str = &quot;chain.dat&quot;;
const DB_MAGIC: &amp;[u8] = &quot;TABCONF24&quot;.as_bytes();
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create a wallet and get a new address and current wallet balance

 let db = Store::&lt;bdk::wallet::ChangeSet&gt;::new_from_path(DB_MAGIC, CHAIN_DATA_FILE)?;

 // Create a new wallet
 let mut wallet = Wallet::new(external_descriptor, Some(internal_descriptor), db, network)?;

 // Get a new wallet address
 let address = wallet.get_address(AddressIndex::New);
 println!(&quot;Generated Address: {:?}&quot;, address);

 // Get the wallet balance before syncing
 let balance = wallet.get_balance();
 println!(&quot;Wallet balance before syncing: confirmed {} sats, trusted_pending {} sats, untrusted pending {} sats&quot;, balance.confirmed, balance.trusted_pending, balance.untrusted_pending);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Add code to create an async esplora client:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bdk_esplora::esplora_client;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> // Create an async esplora client

 let client = esplora_client::Builder::new(&quot;http://signet.bitcoindevkit.net&quot;).build_async()?;
 let prev_tip = wallet.latest_checkpoint();
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Add code to scans keychain SPKs for transaction histories, stopping after <code>stop_gap</code> is reached:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::BTreeMap;
use std::{io, io::Write, str::FromStr};
use bdk::chain::keychain::WalletUpdate;
use bdk::{bitcoin::Network, descriptor, KeychainKind, Wallet};
use bdk_esplora::{esplora_client, EsploraAsyncExt};

const STOP_GAP: usize = 50;
const PARALLEL_REQUESTS: usize = 5;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> // Prepare the `IndexedTxGraph` update based on whether we are scanning or syncing.

 // Scanning: We are iterating through spks of all keychains and scanning for transactions for
 //   each spk. We start with the lowest derivation index spk and stop scanning after `stop_gap`
 //   number of consecutive spks have no transaction history. A Scan is done in situations of
 //   wallet restoration. It is a special case. Applications should use &quot;sync&quot; style updates
 //   after an initial scan.
 if prompt(&quot;Scan wallet&quot;) {
     let keychain_spks = wallet
         .spks_of_all_keychains()
         .into_iter()
         // This `map` is purely for logging.
         .map(|(keychain, iter)| {
             let mut first = true;
             let spk_iter = iter.inspect(move |(i, _)| {
                 if first {
                     // TODO impl Display for Keychain
                     eprint!(
                         &quot;\nscanning {}: &quot;,
                         match keychain {
                             KeychainKind::External =&gt; &quot;External&quot;,
                             KeychainKind::Internal =&gt; &quot;Internal&quot;,
                         }
                     );
                     first = false;
                 }
                 eprint!(&quot;{} &quot;, i);
                 // Flush early to ensure we print at every iteration.
                 let _ = io::stderr().flush();
             });
             (keychain, spk_iter)
         })
         .collect::&lt;BTreeMap&lt;_, _&gt;&gt;();

     // The client scans keychain spks for transaction histories, stopping after `stop_gap`
     // is reached. It returns a `TxGraph` update (`graph_update`) and a structure that
     // represents the last active spk derivation indices of keychains
     // (`keychain_indices_update`).
     let (graph_update, last_active_indices) = client
         .update_tx_graph(
             keychain_spks,
             core::iter::empty(),
             core::iter::empty(),
             STOP_GAP,
             PARALLEL_REQUESTS,
         )
         .await?;

     println!();
     let missing_heights = wallet.tx_graph().missing_heights(wallet.local_chain());
     let chain_update = client
         .update_local_chain(prev_tip.clone(), missing_heights)
         .await?;

     let update = WalletUpdate {
         last_active_indices,
         graph: graph_update,
         chain: chain_update,
     };
     wallet.apply_update(update)?;
     wallet.commit()?;
     println!(&quot;Scan completed.&quot;);

     let balance = wallet.get_balance();
     println!(&quot;Wallet balance after scanning: confirmed {} sats, trusted_pending {} sats, untrusted pending {} sats&quot;,
              balance.confirmed, balance.trusted_pending, balance.untrusted_pending);
 }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Add code to sync wallet by checking for history on all derived SPKs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use bdk::bitcoin::{bip32, Address, OutPoint, ScriptBuf, Txid};
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> // Syncing: We only check for specified spks, utxos and txids to update their confirmation
 //   status or fetch missing transactions.
 else {
     // Spks, outpoints and txids we want updates on will be accumulated here.
     let mut spks: Box&lt;Vec&lt;ScriptBuf&gt;&gt; = Box::new(Vec::new());
     let mut outpoints: Box&lt;dyn Iterator&lt;Item = OutPoint&gt; + Send&gt; =
         Box::new(core::iter::empty());
     let mut txids: Box&lt;dyn Iterator&lt;Item = Txid&gt; + Send&gt; = Box::new(core::iter::empty());

     // Sync all SPKs
     if prompt(&quot;Sync all SPKs&quot;) {
         // TODO add Wallet::all_spks() function, gives all tracked spks
         let all_spks: Vec&lt;ScriptBuf&gt; = wallet
             .spk_index()
             .all_spks()
             .into_iter()
             .map(|((keychain, index), script)| {
                 eprintln!(
                     &quot;Checking if keychain: {}, index: {}, address: {} has been used&quot;,
                     match keychain {
                         KeychainKind::External =&gt; &quot;External&quot;,
                         KeychainKind::Internal =&gt; &quot;Internal&quot;,
                     },
                     index,
                     Address::from_script(script.as_script(), network).unwrap(),
                 );
                 // Flush early to ensure we print at every iteration.
                 let _ = io::stderr().flush();
                 (*script).clone()
             })
             .collect();
         spks = Box::new(all_spks);
     }

     let graph_update = client
         .update_tx_graph_without_keychain(spks.into_iter(), txids, outpoints, PARALLEL_REQUESTS)
         .await?;

     let missing_heights = wallet.tx_graph().missing_heights(wallet.local_chain());
     let chain_update = client.update_local_chain(prev_tip, missing_heights).await?;

     let update = WalletUpdate {
         // no update to active indices
         last_active_indices: BTreeMap::new(),
         graph: graph_update,
         chain: chain_update,
     };
     wallet.apply_update(update)?;
     wallet.commit()?;
     println!(&quot;Sync completed.&quot;);

     let balance = wallet.get_balance();
     println!(&quot;Wallet balance after syncing: confirmed {} sats, trusted_pending {} sats, untrusted pending {} sats&quot;,
              balance.confirmed, balance.trusted_pending, balance.untrusted_pending);
 }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Add code to sync wallet by checking for history on only unused SPKs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>     // Sync only unused SPKs
     else if prompt(&quot;Sync only unused SPKs&quot;) {
         // TODO add Wallet::unused_spks() function, gives all unused tracked spks
         let unused_spks: Vec&lt;ScriptBuf&gt; = wallet
             .spk_index()
             .unused_spks(..)
             .into_iter()
             .map(|((keychain, index), script)| {
                 eprintln!(
                     &quot;Checking if keychain: {}, index: {}, address: {} has been used&quot;,
                     match keychain {
                         KeychainKind::External =&gt; &quot;External&quot;,
                         KeychainKind::Internal =&gt; &quot;Internal&quot;,
                     },
                     index,
                     Address::from_script(script, network).unwrap(),
                 );
                 // Flush early to ensure we print at every iteration.
                 let _ = io::stderr().flush();
                 ScriptBuf::from(script)
             })
             .collect();
         spks = Box::new(unused_spks);
     }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Add code to sync wallet UTXOs to see if any have been spent:</p>
</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>     // Sync UTXOs
     if prompt(&quot;Sync UTXOs&quot;) {
         // We want to search for whether the UTXO is spent, and spent by which
         // transaction. We provide the outpoint of the UTXO to
         // `EsploraExt::update_tx_graph_without_keychain`.
         let utxo_outpoints = wallet
             .list_unspent()
             .inspect(|utxo| {
                 eprintln!(
                     &quot;Checking if outpoint {} (value: {}) has been spent&quot;,
                     utxo.outpoint, utxo.txout.value
                 );
                 // Flush early to ensure we print at every iteration.
                 let _ = io::stderr().flush();
             })
             .map(|utxo| utxo.outpoint);
         outpoints = Box::new(utxo_outpoints);
     };
<span class="boring">}</span></code></pre></pre>
<ol start="11">
<li>Add code to sync wallet unconfirmed TXs:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>     // Sync unconfirmed TX
     if prompt(&quot;Sync unconfirmed TX&quot;) {
         // We want to search for whether the unconfirmed transaction is now confirmed.
         // We provide the unconfirmed txids to
         // `EsploraExt::update_tx_graph_without_keychain`.
         let unconfirmed_txids = wallet
             .transactions()
             .filter(|canonical_tx| !canonical_tx.chain_position.is_confirmed())
             .map(|canonical_tx| canonical_tx.tx_node.txid)
             .inspect(|txid| {
                 eprintln!(&quot;Checking if {} is confirmed yet&quot;, txid);
                 // Flush early to ensure we print at every iteration.
                 let _ = io::stderr().flush();
             });
         txids = Box::new(unconfirmed_txids);
     }
<span class="boring">}</span></code></pre></pre>
<ol start="12">
<li>Add code to check the new wallet balance and request a deposit if required:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SEND_AMOUNT: u64 = 5000;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> // Check balance and request deposit if required
 if balance.total() &lt; SEND_AMOUNT {
     println!(
         &quot;Please send at least {} sats to {} using: https://signetfaucet.com/&quot;,
         SEND_AMOUNT, address.address
     );
     std::process::exit(0);
 }
<span class="boring">}</span></code></pre></pre>
<ol start="13">
<li>Add code to create a TX to return sats to the <a href="https://signetfaucet.com/">signet faucet</a>:</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> // Create TX to return sats to signet faucet https://signetfaucet.com/
 let faucet_address = Address::from_str(&quot;tb1qg3lau83hm9e9tdvzr5k7aqtw3uv0dwkfct4xdn&quot;)?
     .require_network(network)?;

 let mut tx_builder = wallet.build_tx();
 tx_builder
     .add_recipient(faucet_address.script_pubkey(), SEND_AMOUNT)
     // .drain_to(faucet_address.script_pubkey())
     // .drain_wallet()
     .fee_rate(FeeRate::from_sat_per_vb(2.1))
     .enable_rbf();

 let mut psbt = tx_builder.finish()?;
 let finalized = wallet.sign(&amp;mut psbt, SignOptions::default())?;
 assert!(finalized);

 let tx = psbt.extract_tx();
 let (sent, received) = wallet.sent_and_received(&amp;tx);
 let fee = wallet.calculate_fee(&amp;tx).expect(&quot;fee&quot;);
 let fee_rate = wallet
     .calculate_fee_rate(&amp;tx)
     .expect(&quot;fee rate&quot;)
     .as_sat_per_vb();
 println!(
     &quot;Created tx sending {} sats to {}&quot;,
     sent - received - fee,
     faucet_address
 );
 println!(
     &quot;Fee is {} sats, fee rate is {:.2} sats/vbyte&quot;,
     fee, fee_rate
 );

 if prompt(&quot;Broadcast&quot;) {
     client.broadcast(&amp;tx).await?;
     println!(
         &quot;Tx broadcast! https://mempool.space/signet/tx/{}&quot;,
         tx.txid()
     );
 }
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chain.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chain.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
